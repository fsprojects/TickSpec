namespace TickSpec.Xunit

open System.Collections.Generic
open TickSpec
open Xunit.Abstractions

/// A (Xunit) serializable equivalent of TickSpec.Scenario without the non-serializable Action property,
/// so that example-based scenarios can be individually debugged/run in dotnet test -t, VS, Rider
type XunitSerializableScenario =
    val mutable FeatureName: string
    val mutable Name: string
    val mutable Parameters: (string*string)[]
    val mutable Tags: string[]
    val mutable Rule: string option
    new (featureName: string, name: string, parameters: (string*string)[], tags: string[], rule: string option) = { FeatureName = featureName; Name = name; Parameters = parameters; Tags = tags; Rule = rule }
    new () = XunitSerializableScenario("", "", Array.empty, Array.empty, None)

    override this.ToString() =
        let baseName =
            match this.Rule with
            | Some rule -> sprintf "[%s] %s" rule this.Name
            | None -> this.Name
        if this.Parameters.Length = 0 && this.Tags.Length = 0 then baseName
        else
            let parameters =  this.Parameters |> Seq.map (fun (k,v) -> sprintf "%s=%s" k v) |> String.concat ","
            let tags =  this.Tags |> String.concat ","
            sprintf "%s<%s>{%s}" baseName tags parameters

    interface IXunitSerializable with
        member this.Serialize (info:IXunitSerializationInfo) =
            info.AddValue("FeatureName", this.FeatureName)
            info.AddValue("Name", this.Name)
            info.AddValue("Parameters", [| for k, v in this.Parameters -> sprintf "%s=%s" k v |])
            info.AddValue("Tags", this.Tags)
            match this.Rule with
            | Some rule -> info.AddValue("Rule", rule)
            | None -> ()

        member this.Deserialize(info:IXunitSerializationInfo) =
            let featureName = info.GetValue<string>("FeatureName")
            let name = info.GetValue<string>("Name")
            let parameters =
                info.GetValue<string[]>("Parameters")
                |> Array.map (fun kv ->
                    let kva = kv.Split([|'='|], 2)  // max 2 substrings as the value itself may contain '='
                    kva.[0], kva.[1])
            let tags = info.GetValue<string[]>("Tags")
            let rule =
                let ruleValue = info.GetValue<string>("Rule")
                if isNull ruleValue then None else Some ruleValue
            this.FeatureName <- featureName
            this.Name <- name
            this.Parameters <- parameters
            this.Tags <- tags
            this.Rule <- rule
            
/// Represents a set of Step Definitions available within a given Assembly
type AssemblyStepDefinitionsSource(assembly : System.Reflection.Assembly) =
    let definitions = StepDefinitions(assembly)
    let scenarioActions : Dictionary<string, Action> = Dictionary<string, Action>() 

    let createScenarioActionsKey featureName scenarioName = sprintf "%s/%s" featureName scenarioName 
    
    /// Yields Scenarios generated by parsing the supplied Resource Name and binding the steps to their Step Definitions
    member __.ScenariosFromEmbeddedResource resourceName : XunitSerializableScenario seq =
        let stream = assembly.GetManifestResourceStream(resourceName)
        let scenarios = definitions.GenerateScenarios(resourceName, stream)
        scenarios
        |> Seq.iter (fun s ->
            scenarioActions.[createScenarioActionsKey resourceName s.Name] <- s.Action)
        
        scenarios
        |> Seq.map (fun s ->
            XunitSerializableScenario (resourceName, s.Name, s.Parameters, s.Tags, s.Rule))

    /// Executes the scenario
    member __.RunScenario(scenario: XunitSerializableScenario) =
        let scenarioActionsKey = createScenarioActionsKey scenario.FeatureName scenario.Name

        if not (scenarioActions.ContainsKey scenarioActionsKey) then
            __.ScenariosFromEmbeddedResource scenario.FeatureName |> ignore

        scenarioActions.[scenarioActionsKey].Invoke()

    /// Hook creation of a container scope per Scenario Run so creation is via the specified factory
    member __.ServiceProviderFactory
        with set factory = definitions.ServiceProviderFactory <- factory

/// Adapts a Scenario Sequence to match the required format for an xUnit MemberData attribute
module MemberData =
    let ofScenarios xs = xs |> Seq.map (fun x -> [| x |])
